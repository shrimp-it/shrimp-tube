<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>YouTube Video Recorder</title>
<style>
/* Base Styles */
body {
font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
margin: 0;
background-color: #f4f4f4;
color: #333;
line-height: 1.6;
display: flex;
justify-content: center;
align-items: flex-start;
min-height: 100vh;
padding: 20px;
box-sizing: border-box;
transition: background-color 0.3s ease; /* For smooth transition to dark mode */
}

.container {
max-width: 1200px;
width: 100%;
margin: 0;
background: #fff;
padding: 30px;
border-radius: 8px;
box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
display: flex;
flex-direction: column;
gap: 20px;
transition: all 0.3s ease; /* For smooth transition when maximizing */
position: relative;
z-index: 1; /* Ensure container is above other elements in normal flow */
}

h1, h2 {
color: #0056b3;
border-bottom: 1px solid #eee;
padding-bottom: 10px;
margin-bottom: 20px;
}

/* Input and Control Layout */
.input-controls {
display: flex;
flex-wrap: wrap;
gap: 20px;
align-items: flex-end;
}

.input-group {
flex: 1 1 250px;
margin-bottom: 0;
}

.input-group.full-width {
flex-basis: 100%;
}

.input-group label {
display: block;
margin-bottom: 5px;
font-weight: bold;
color: #555;
}

.input-group input[type="text"],
.input-group select {
width: 100%;
padding: 10px;
border: 1px solid #ddd;
border-radius: 4px;
font-size: 16px;
box-sizing: border-box;
}

.input-group input[type="text"]:focus,
.input-group select:focus {
border-color: #007bff;
outline: none;
box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25);
}

/* Button Styling */
.button-group {
display: flex;
flex-wrap: wrap;
gap: 10px;
margin-top: 10px;
}

.button-group button {
padding: 12px 20px;
border: none;
border-radius: 5px;
cursor: pointer;
font-size: 16px;
font-weight: bold;
transition: background-color 0.2s ease, transform 0.1s ease;
flex-grow: 1;
min-width: 150px;
}

.button-group button:hover:not(:disabled) {
transform: translateY(-1px);
}

.button-group button:disabled {
background-color: #cccccc;
cursor: not-allowed;
color: #666;
}

.button-group .btn-primary { background-color: #007bff; color: white; }
.button-group .btn-primary:hover:not(:disabled) { background-color: #0056b3; }
.button-group .btn-success { background-color: #28a745; color: white; }
.button-group .btn-success:hover:not(:disabled) { background-color: #218838; }
.button-group .btn-warning { background-color: #ffc107; color: #333; }
.button-group .btn-warning:hover:not(:disabled) { background-color: #e0a800; }
.button-group .btn-danger { background-color: #dc3545; color: white; }
.button-group .btn-danger:hover:not(:disabled) { background-color: #c82333; }

/* YouTube Player Styling */
#player-container {
width: 100%;
aspect-ratio: 16 / 9;
background-color: #000;
margin-top: 10px;
border-radius: 4px;
overflow: hidden;
transition: all 0.3s ease; /* Smooth transition for player resizing */
}

#player {
width: 100%;
height: 100%;
}

/* Status Display */
#status-display {
background-color: #e9ecef;
border: 1px solid #ced4da;
padding: 15px;
margin-top: 20px;
border-radius: 4px;
text-align: center;
font-size: 1.1em;
font-weight: bold;
color: #007bff;
}

#recording-time {
color: #dc3545;
font-size: 1.5em;
margin-top: 5px;
}

/* Download Link */
#download-link-container {
margin-top: 25px;
padding: 15px;
background-color: #d4edda;
border: 1px solid #c3e6cb;
border-radius: 4px;
text-align: center;
}

#download-link {
font-size: 1.1em;
color: #155724;
text-decoration: none;
font-weight: bold;
}

#download-link:hover {
text-decoration: underline;
}

/* Instructions */
.instructions {
background-color: #f8f9fa;
border: 1px solid #dee2e6;
padding: 20px;
border-radius: 4px;
margin-top: 30px;
}

.instructions h3 {
color: #0056b3;
margin-bottom: 10px;
}

.instructions ul {
list-style-type: disc;
margin-left: 20px;
}

.instructions li {
margin-bottom: 8px;
}

.error-message {
color: #dc3545;
font-weight: bold;
margin-top: 10px;
flex-basis: 100%;
}

/* Maximize Mode */
body.maximized-mode {
overflow: hidden; /* Hide scrollbars */
background-color: #1a1a1a; /* Dark background when maximized */
}

body.maximized-mode .container {
padding: 0;
box-shadow: none;
border-radius: 0;
background: #1a1a1a; /* Dark background for the container too */
position: fixed; /* Take over the viewport */
top: 0;
left: 0;
width: 100vw;
height: 100vh;
display: block; /* Override flex for main container to behave as a single block */
}

body.maximized-mode .input-controls,
body.maximized-mode .button-group,
body.maximized-mode .instructions,
body.maximized-mode #status-display,
body.maximized-mode #download-link-container,
body.maximized-mode h1 {
display: none !important; /* Force hide these elements */
}

body.maximized-mode #player-container {
position: fixed; /* Fill the whole screen */
top: 0;
left: 0;
width: 100vw;
height: 100vh;
z-index: 1000; /* Player behind overlay controls (z-index: 2000) */
border-radius: 0;
margin-top: 0;
aspect-ratio: unset; /* Let height/width dictate size */
}

/* Overlay Controls for Maximize Mode */
#overlay-controls {
position: fixed;
top: 0;
left: 0;
width: 100vw;
height: 20px;
background-color: rgba(0, 0, 0, 0.7); /* Subtle black background */
display: flex;
justify-content: flex-end; /* Align buttons to the right */
align-items: center;
z-index: 2000; /* Ensure it's above everything */
padding: 0 10px;
box-sizing: border-box;
visibility: hidden; /* Hidden by default, JavaScript controls display */
opacity: 0;
transition: opacity 0.3s ease-in-out;
pointer-events: none; /* Do not block clicks by default */
}

#overlay-controls.visible {
visibility: visible;
opacity: 1;
pointer-events: all; /* Allow clicks when visible */
}

.overlay-btn {
padding: 2px 8px;
font-size: 12px;
height: 18px;
line-height: 1;
border-radius: 3px;
margin-left: 5px; /* Spacing between buttons */
background-color: rgba(255, 255, 255, 0.05); /* Very subtle, dark background */
color: #ccc; /* Light gray text */
border: 1px solid rgba(255, 255, 255, 0.1);
cursor: pointer;
transition: background-color 0.2s ease, color 0.2s ease, border-color 0.2s ease;
}

.overlay-btn:hover:not(:disabled) {
background-color: rgba(255, 255, 255, 0.15);
color: #fff;
border-color: rgba(255, 255, 255, 0.3);
}
.overlay-btn:disabled {
background-color: rgba(100, 100, 100, 0.1);
border-color: rgba(100, 100, 100, 0.2);
color: #777;
cursor: not-allowed;
}

.overlay-btn.btn-warning { /* Example for Pause */
background-color: rgba(255, 193, 7, 0.1);
border-color: rgba(255, 193, 7, 0.2);
color: #ffc107;
}
.overlay-btn.btn-warning:hover:not(:disabled) {
background-color: rgba(255, 193, 7, 0.2);
border-color: rgba(255, 193, 7, 0.4);
color: #fff;
}

.overlay-btn.btn-danger { /* Example for Stop */
background-color: rgba(220, 53, 69, 0.1);
border-color: rgba(220, 53, 69, 0.2);
color: #dc3545;
}
.overlay-btn.btn-danger:hover:not(:disabled) {
background-color: rgba(220, 53, 69, 0.2);
border-color: rgba(220, 53, 69, 0.4);
color: #fff;
}

.overlay-btn.btn-primary { /* Example for Exit */
background-color: rgba(0, 123, 255, 0.1);
border-color: rgba(0, 123, 255, 0.2);
color: #007bff;
}
.overlay-btn.btn-primary:hover:not(:disabled) {
background-color: rgba(0, 123, 255, 0.2);
border-color: rgba(0, 123, 255, 0.4);
color: #fff;
}


/* Responsive adjustments */
@media (max-width: 768px) {
.input-controls {
flex-direction: column;
gap: 15px;
}
.input-group, .input-group.full-width {
flex-basis: auto;
width: 100%;
}
.button-group button {
min-width: unset;
flex-basis: auto;
}
}
</style>
</head>
<body>
<div class="container">
<h1>YouTube Video Recorder</h1>

<div class="input-controls">
<div class="input-group full-width">
<label for="youtube-link">YouTube Video ID oder Link:</label>
<input type="text" id="youtube-link" placeholder="z.B. dQw4w9WgXcQ oder https://www.youtube.com/watch?v=dQw4w9WgXcQ">
</div>

<div class="input-group">
<label for="playback-speed">Abspielgeschwindigkeit:</label>
<select id="playback-speed">
<option value="1">1x (Normal)</option>
<option value="2">2x (Doppelt)</option>
</select>
</div>

<div class="input-group">
<label for="start-time">Startzeit (MM:SS, optional):</label>
<input type="text" id="start-time" placeholder="z.B. 01:30">
</div>
<div class="input-group">
<label for="end-time">Endzeit (MM:SS, optional):</label>
<input type="text" id="end-time" placeholder="z.B. 10:45">
</div>
<div id="time-error" class="error-message"></div>
</div>

<div class="button-group">
<button id="load-video-btn" class="btn-primary">Video Laden</button>
<button id="toggle-maximize-btn" class="btn-primary" disabled>Video vergrößern</button>
<button id="start-video-btn" class="btn-primary" disabled>Video Starten</button>
<button id="start-record-btn" class="btn-success" disabled>Video Starten & Aufnehmen</button>
<button id="pause-record-btn" class="btn-warning" disabled>Pause Video & Aufnahme</button>
<button id="stop-record-btn" class="btn-danger" disabled>Stop Video & Aufnahme</button>
</div>

<div id="player-container">
<div id="player"></div>
</div>

<div id="status-display" style="display: none;">
<p>Status: <span id="recording-status-text">Bereit</span></p>
<p>Restlaufzeit Aufnahme: <span id="recording-time">--:--</span></p>
</div>

<div id="download-link-container" style="display: none;">
<p>Aufnahme abgeschlossen! Hier geht's zum Download:</p>
<a id="download-link" href="#" download="yt-video.webm">Herunterladen</a>
</div>

<div class="instructions">
<h3>Wichtige Hinweise zur Aufnahme:</h3>
<ul>
<li><strong>Browser-Auswahldialog:</strong> Beim Start der Aufnahme öffnet sich ein Browser-Dialog. Wählen Sie dort die Option "Diesen Tab" und aktivieren Sie *unbedingt* die Checkbox "Tab-Audio freigeben" (oder ähnlich, der genaue Text kann je nach Browser variieren), um Audio mit aufzunehmen.</li>
<li><strong>Ganze Tab-Aufnahme:</strong> Die Technologie erlaubt es derzeit nicht, nur das YouTube-Video zu isolieren. Die Aufnahme erfasst den *gesamten Inhalt dieses Browser-Tabs*. Um unerwünschte Elemente (z.B. Browser-Leisten, Scrollbalken, diese Anleitung) zu minimieren, empfehlen wir:
<ol>
<li>Schließen Sie alle nicht benötigten Browser-Tabs.</li>
<li>Stellen Sie den Browser vor dem Start der Aufnahme in den <strong>Vollbildmodus (F11 oder Browser-Menü)</strong>.</li>
<li>Zoomen Sie gegebenenfalls (Strg/Cmd + scrollen), um den YouTube-Player optimal im Sichtfeld zu platzieren.</li>
<li>Nutzen Sie die Funktion "Video vergrößern" für eine optimierte Ansicht während der Aufnahme.</li>
</ol>
</li>
<li><strong>Tab aktiv halten:</strong> Der Browser-Tab, in dem diese App läuft, muss während der gesamten Aufnahme geöffnet, aktiv und sichtbar bleiben (nicht minimieren oder in den Hintergrund schieben). Andernfalls kann die Aufnahme stoppen oder fehlerhaft sein (z.B. nur ein schwarzes Bild oder fehlendes Audio).</li>
<li><strong>Keine Ablenkungen:</strong> Vermeiden Sie es, während der Aufnahme andere Audio- oder Videostreams in anderen Tabs oder Anwendungen zu starten, um Störungen der Audioaufnahme zu verhindern.</li>
<li><strong>Lange Videos:</strong> Bei sehr langen Videos (z.B. 3.5 Stunden) kann die finale Datei sehr groß werden. Stellen Sie sicher, dass Sie genügend Speicherplatz haben.</li>
<li><strong>2x Geschwindigkeit:</strong> Wenn Sie die 2x Geschwindigkeit wählen, wird das Video auch mit doppelter Geschwindigkeit aufgenommen. Die resultierende Datei muss vom Nutzer selbst mit normaler Geschwindigkeit wiedergegeben werden, falls gewünscht. Der Dateiname wird die 2x-Option kennzeichnen.</li>
<li><strong>Vergrößerter Modus:</strong> Im vergrößerten Modus können Sie die Aufnahme mit den dezenten Buttons am oberen Bildschirmrand pausieren/fortsetzen oder stoppen. Drücken Sie `ESC`, um den vergrößerten Modus zu verlassen.</li>
</ul>
</div>
</div>

<!-- Overlay Controls (hidden by default) -->
<div id="overlay-controls">
<button id="overlay-pause-btn" class="overlay-btn btn-warning" title="Pause / Fortsetzen">Pause</button>
<button id="overlay-stop-btn" class="overlay-btn btn-danger" title="Aufnahme stoppen">Stop</button>
<button id="overlay-minimize-btn" class="overlay-btn btn-primary" title="Verkleinern (ESC)">Exit</button>
</div>

<script>
// Global variables for YouTube Player and Media Recorder
let player;
let mediaRecorder;
let recordedChunks = [];
let stream;
let currentVideoId = '';
let recordingInterval;
let segmentDurationSeconds = 0; // Duration of the segment to be recorded
let startTimeSeconds = 0;
let endTimeSeconds = 0;
let isRecording = false;
let isPaused = false;
let isMaximized = false; // New state variable for maximize mode

// --- Utility Functions ---
function parseYouTubeLink(link) {
let videoId = '';
// Regex to find video ID from various YouTube URL formats
const regex = /(?:youtube\.com\/(?:[^\/\n\s]+\/\S+\/|(?:v|e(?:mbed)?)\/|.*[?&]v=)|youtu\.be\/)([a-zA-Z0-9_-]{11})/;
const match = link.match(regex);
if (match && match[1]) {
videoId = match[1];
} else if (link.length === 11 && /^[a-zA-Z0-9_-]{11}$/.test(link)) {
// If it's just an ID
videoId = link;
}
return videoId;
}

function formatTime(seconds) {
const h = Math.floor(seconds / 3600);
const m = Math.floor((seconds % 3600) / 60);
const s = Math.floor(seconds % 60);
return `${h > 0 ? h.toString().padStart(2, '0') + ':' : ''}${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
}

function parseTime(timeString) {
if (!timeString) return null;
const parts = timeString.split(':').map(Number);
if (parts.length === 2 && !isNaN(parts[0]) && !isNaN(parts[1])) {
return parts[0] * 60 + parts[1]; // MM:SS to seconds
}
return null;
}

function validateTimeInputs(duration) {
const startInput = document.getElementById('start-time').value;
const endInput = document.getElementById('end-time').value;
const timeError = document.getElementById('time-error');
timeError.textContent = ''; // Clear previous errors

let s = parseTime(startInput);
let e = parseTime(endInput);

// If no start/end time, use full video duration
startTimeSeconds = s !== null ? s : 0;
endTimeSeconds = e !== null ? e : duration;

if (startInput && s === null) {
timeError.textContent = 'Ungültiges Startzeit-Format. Bitte MM:SS verwenden.';
return false;
}
if (endInput && e === null) {
timeError.textContent = 'Ungültiges Endzeit-Format. Bitte MM:SS verwenden.';
return false;
}

if (startTimeSeconds >= duration) {
timeError.textContent = 'Startzeit kann nicht nach Videoende liegen.';
return false;
}
if (endTimeSeconds > duration) {
timeError.textContent = 'Endzeit kann nicht nach Videoende liegen. Auf Videoende gesetzt.';
endTimeSeconds = duration; // Clamp end time to video duration
}
if (startTimeSeconds >= endTimeSeconds) {
timeError.textContent = 'Startzeit muss vor der Endzeit liegen.';
return false;
}
return true;
}


// --- YouTube Player API ---
function onYouTubeIframeAPIReady() {
player = new YT.Player('player', {
height: '100%',
width: '100%',
videoId: '', // Will be set dynamically
playerVars: {
playsinline: 1,
autoplay: 0,
controls: 1,
showinfo: 0,
rel: 0,
modestbranding: 1
},
events: {
'onReady': onPlayerReady,
'onStateChange': onPlayerStateChange,
'onError': onPlayerError
}
});
}

function onPlayerReady(event) {
console.log("YouTube Player is ready. Activating initial buttons.");
// Activate all non-recording specific buttons, regardless of video loaded state.
// This is the core of the user's request.
document.getElementById('load-video-btn').disabled = false;
document.getElementById('toggle-maximize-btn').disabled = false;
document.getElementById('start-video-btn').disabled = false;
document.getElementById('start-record-btn').disabled = false;

// Recording-specific buttons remain disabled until recording starts.
document.getElementById('pause-record-btn').disabled = true;
document.getElementById('stop-record-btn').disabled = true;

// Input fields are active
document.getElementById('youtube-link').disabled = false;
document.getElementById('playback-speed').disabled = false;
document.getElementById('start-time').disabled = false;
document.getElementById('end-time').disabled = false;

document.getElementById('status-display').style.display = 'none'; // Ensure hidden initially
document.getElementById('download-link-container').style.display = 'none'; // Ensure hidden initially
}

function onPlayerStateChange(event) {
// Player states: -1 (unstarted), 0 (ended), 1 (playing), 2 (paused), 3 (buffering), 5 (video cued)

if (event.data === YT.PlayerState.PLAYING) {
if (isRecording) {
const speed = parseFloat(document.getElementById('playback-speed').value);
if (player.getCurrentTime() >= endTimeSeconds - (0.5 / speed)) { // A small buffer
console.log("Player reached end time during recording, stopping recording.");
stopRecording();
} else if (!recordingInterval) {
startRecordingTimer();
}
}
} else if (event.data === YT.PlayerState.ENDED) {
if (isRecording) {
console.log("Player indicated video ended, stopping recording.");
stopRecording();
}
} else if (event.data === YT.PlayerState.PAUSED) {
if (isRecording && !isPaused) { // If player was paused externally by user
console.log("Player paused externally, pausing recording.");
pauseRecording();
}
}
// Update overlay controls visibility based on current state
updateOverlayControlsVisibility();
}

function onPlayerError(event) {
console.error("YouTube Player Error:", event.data);
alert(`Ein YouTube Player Fehler ist aufgetreten: ${event.data}. Bitte überprüfen Sie die Video ID/den Link.`);
stopRecording(true); // Force stop and reset UI on error
}

function loadVideo() {
const linkInput = document.getElementById('youtube-link').value.trim();
const videoId = parseYouTubeLink(linkInput);

if (!videoId) {
alert('Bitte geben Sie eine gültige YouTube Video ID oder einen Link ein.');
currentVideoId = ''; // Clear potentially invalid video ID
resetAppUI(); // Reset UI to its default activated state
return;
}

currentVideoId = videoId;
document.getElementById('download-link-container').style.display = 'none';
document.getElementById('status-display').style.display = 'none';
document.getElementById('recording-time').textContent = '--:--';
document.getElementById('recording-status-text').textContent = 'Video wird geladen...';
document.getElementById('time-error').textContent = '';

// Even during loading, per user request, most buttons remain active.
// Only recording specific ones and inputs are conditionally managed.
document.getElementById('load-video-btn').disabled = false; // Always active
document.getElementById('toggle-maximize-btn').disabled = false;
document.getElementById('start-video-btn').disabled = false;
document.getElementById('start-record-btn').disabled = false;
document.getElementById('pause-record-btn').disabled = true; // No recording yet
document.getElementById('stop-record-btn').disabled = true; // No recording yet

// Input fields can be disabled briefly to prevent changes while loading
document.getElementById('youtube-link').disabled = true;
document.getElementById('playback-speed').disabled = true;
document.getElementById('start-time').disabled = true;
document.getElementById('end-time').disabled = true;


if (player) {
player.loadVideoById(videoId, startTimeSeconds);
player.setPlaybackRate(parseFloat(document.getElementById('playback-speed').value));
player.pauseVideo(); // Ensure it's paused after loading

// Immediately re-enable inputs as the video is cued/loaded and player state will update
// This will be handled by resetAppUI in a moment, but setting currentVideoId allows it.
// Or, simply, rely on the onPlayerStateChange(CUED) to call resetAppUI.
}
}

// --- Screen Recorder Logic ---
async function startRecording() {
if (isRecording) {
console.warn("Recording is already active.");
return;
}

if (!currentVideoId) {
alert('Bitte laden Sie zuerst ein YouTube-Video.');
return;
}

// Perform final validation just before starting recording.
// If the player isn't playing (state 1), its duration might not be fully reliable yet.
// Ensure player is cued or playing to get duration.
const playerState = player.getPlayerState();
if (playerState === YT.PlayerState.UNSTARTED || playerState === YT.PlayerState.BUFFERING) {
alert('Video ist noch nicht bereit zum Starten. Bitte warten Sie einen Moment und versuchen Sie es erneut.');
return;
}

if (!validateTimeInputs(player.getDuration())) {
return;
}
segmentDurationSeconds = (endTimeSeconds - startTimeSeconds);

const speed = parseFloat(document.getElementById('playback-speed').value);
player.setPlaybackRate(speed); // Apply speed before playing
player.seekTo(startTimeSeconds, true);
player.playVideo();

try {
// Request access to the current tab for screen and audio capture
stream = await navigator.mediaDevices.getDisplayMedia({
video: { mediaSource: 'tab' },
audio: { mediaSource: 'tab' }, // Request audio from the tab
preferCurrentTab: true // Hint to browser to prioritize current tab
});

// Check if the stream includes audio
if (!stream.getAudioTracks().length) {
alert("Wichtig: Sie müssen im Browser-Dialog 'Tab-Audio freigeben' aktivieren, damit Audio mit aufgenommen wird.");
// Still proceed with video, but inform user
}

// If the user stops screen sharing from the browser's UI
stream.getVideoTracks()[0].onended = () => {
console.log("Screen sharing stopped by user.");
if (isRecording) {
stopRecording(true); // Force stop recording if screen sharing ends
}
};


mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm; codecs=vp8,opus' }); // WebM with VP8 video and Opus audio

recordedChunks = [];
mediaRecorder.ondataavailable = (event) => {
if (event.data.size > 0) {
recordedChunks.push(event.data);
}
};

mediaRecorder.onstop = () => {
console.log("Recording stopped.");
const blob = new Blob(recordedChunks, { type: 'video/webm' });
const url = URL.createObjectURL(blob);
const downloadLink = document.getElementById('download-link');
downloadLink.href = url;
const speedSuffix = speed === 2 ? '_2x' : '';
downloadLink.download = `yt-video-${currentVideoId}${speedSuffix}.webm`;
document.getElementById('download-link-container').style.display = 'block';

// Stop all tracks in the stream if still active
if (stream) {
stream.getTracks().forEach(track => track.stop());
stream = null;
}
resetAppUI(); // Reset UI after successful stop
};

mediaRecorder.onerror = (event) => {
console.error("MediaRecorder Error:", event.error);
alert(`Fehler bei der Aufnahme: ${event.error.name} - ${event.error.message}`);
stopRecording(true); // Stop and reset UI even on error
};

mediaRecorder.start();
isRecording = true;
isPaused = false;
console.log("Recording started.");

// Update UI for recording state - disable all inputs and non-recording buttons
document.getElementById('status-display').style.display = 'block';
document.getElementById('recording-status-text').textContent = 'Aufnahme läuft...';
document.getElementById('load-video-btn').disabled = true;
document.getElementById('start-video-btn').disabled = true;
document.getElementById('start-record-btn').disabled = true;
document.getElementById('playback-speed').disabled = true;
document.getElementById('start-time').disabled = true;
document.getElementById('end-time').disabled = true;
document.getElementById('youtube-link').disabled = true; // Disable input link
document.getElementById('toggle-maximize-btn').disabled = true; // Disable maximize button when recording

document.getElementById('pause-record-btn').disabled = false;
document.getElementById('stop-record-btn').disabled = false;

startRecordingTimer(); // Start timer after successful `getDisplayMedia`
} catch (err) {
console.error("Error starting recording:", err);
if (err.name === "NotFoundError") {
alert("Kein geeignetes Display/Tab gefunden. Stellen Sie sicher, dass Sie die App in einem aktiven Browser-Tab ausführen und die Berechtigung erteilen.");
} else if (err.name === "NotAllowedError") {
alert("Zugriff auf Bildschirmaufnahme verweigert. Bitte erlauben Sie den Zugriff im Browser-Dialog.");
} else if (err.name === "AbortError") {
alert("Bildschirmaufnahme abgebrochen.");
} else {
alert(`Fehler beim Starten der Aufnahme: ${err.message}`);
}
stopRecording(true); // Force stop and reset UI
if (player) player.pauseVideo();
}
updateOverlayControlsVisibility(); // Show overlay if maximized and recording
}

function startRecordingTimer() {
if (recordingInterval) clearInterval(recordingInterval);

recordingInterval = setInterval(() => {
if (!isRecording || isPaused) return;

const currentTime = player.getCurrentTime();
const speed = parseFloat(document.getElementById('playback-speed').value);
let remainingVideoTime = (endTimeSeconds - currentTime);
if (remainingVideoTime < 0) remainingVideoTime = 0;

// Display actual remaining video time, not recording time
const displayedRemainingTime = remainingVideoTime;

document.getElementById('recording-status-text').textContent = 'Aufnahme läuft...';

if (displayedRemainingTime < 60) { // Countdown in seconds
document.getElementById('recording-time').textContent = `${Math.floor(displayedRemainingTime).toString().padStart(2, '0')}s`;
} else { // Display hh:mm
const minutes = Math.floor(displayedRemainingTime / 60);
const seconds = Math.floor(displayedRemainingTime % 60);
document.getElementById('recording-time').textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
}

// Auto-stop when player reaches end time (with a small buffer for timing inaccuracies)
if (currentTime >= endTimeSeconds - (0.5 / speed)) {
console.log("Timer detected end time, stopping recording.");
stopRecording();
}
}, 1000); // Update every second
}

function pauseRecording() {
if (!isRecording || !mediaRecorder) return;
if (isPaused) { // If already paused, resume
mediaRecorder.resume();
player.playVideo();
isPaused = false;
document.getElementById('pause-record-btn').textContent = 'Pause Video & Aufnahme';
document.getElementById('pause-record-btn').classList.remove('btn-primary');
document.getElementById('pause-record-btn').classList.add('btn-warning');
document.getElementById('recording-status-text').textContent = 'Aufnahme läuft...';
startRecordingTimer(); // Resume timer updates
} else { // Pause
mediaRecorder.pause();
player.pauseVideo();
isPaused = true;
document.getElementById('pause-record-btn').textContent = 'Resume Video & Aufnahme';
document.getElementById('pause-record-btn').classList.remove('btn-warning');
document.getElementById('pause-record-btn').classList.add('btn-primary');
document.getElementById('recording-status-text').textContent = 'Aufnahme pausiert.';
if (recordingInterval) clearInterval(recordingInterval);
}
updateOverlayControlsVisibility(); // Update overlay button text/state
}

function stopRecording(forceReset = false) {
if (!isRecording && !forceReset) {
console.warn("No active recording to stop.");
return;
}

// Stop mediaRecorder if active. Its onstop event will handle cleanup.
if (mediaRecorder && mediaRecorder.state !== 'inactive') {
mediaRecorder.stop();
} else {
// If mediaRecorder was never started or already inactive, manually clean up stream and UI.
if (stream) {
stream.getTracks().forEach(track => track.stop());
stream = null;
}
resetAppUI(); // Reset UI immediately
}

if (player) {
player.pauseVideo();
player.seekTo(startTimeSeconds, true); // Reset to start time
}
if (recordingInterval) {
clearInterval(recordingInterval);
recordingInterval = null;
}

isRecording = false;
isPaused = false;
// updateOverlayControlsVisibility() will be called by resetAppUI
}

function resetAppUI() {
// All non-recording specific buttons are always active, per user request.
document.getElementById('load-video-btn').disabled = false;
document.getElementById('toggle-maximize-btn').disabled = false;
document.getElementById('start-video-btn').disabled = false;
document.getElementById('start-record-btn').disabled = false;

// Input fields are enabled unless recording
document.getElementById('youtube-link').disabled = isRecording;
document.getElementById('playback-speed').disabled = isRecording;
document.getElementById('start-time').disabled = isRecording;
document.getElementById('end-time').disabled = isRecording;

// Recording-specific buttons are only active if `isRecording` is true.
document.getElementById('pause-record-btn').disabled = !isRecording;
document.getElementById('stop-record-btn').disabled = !isRecording;

document.getElementById('pause-record-btn').textContent = 'Pause Video & Aufnahme';
document.getElementById('pause-record-btn').classList.remove('btn-primary');
document.getElementById('pause-record-btn').classList.add('btn-warning');

// Reset status display only if not recording
if (!isRecording) {
document.getElementById('status-display').style.display = 'none';
document.getElementById('recording-time').textContent = '--:--';
document.getElementById('recording-status-text').textContent = 'Bereit';
}

// Ensure overlay is hidden and maximized mode is off if recording stops
if (isMaximized && !isRecording) { // Only force minimize if not currently recording
toggleMaximizePlayer(false); // Force minimize
}
updateOverlayControlsVisibility(); // Ensure overlay is hidden
}


// --- Maximize Feature Functions ---
function toggleMaximizePlayer(forceState = null) {
if (isRecording) {
if (forceState === true) { // Allow maximizing even if recording, but only via this path
isMaximized = true;
} else if (forceState === false) { // Allow explicit minimization
isMaximized = false;
} else { // Prevent toggle if recording unless forced
console.warn("Cannot toggle maximize while recording is active. Use overlay buttons or 'Exit' in maximized mode.");
return;
}
} else if (forceState !== null) {
isMaximized = forceState;
} else {
isMaximized = !isMaximized;
}

const body = document.body;
if (isMaximized) {
body.classList.add('maximized-mode');
} else {
body.classList.remove('maximized-mode');
}
// Update visibility of overlay controls based on maximized and recording state
updateOverlayControlsVisibility();
}

function updateOverlayControlsVisibility() {
const overlayControls = document.getElementById('overlay-controls');
const overlayPauseBtn = document.getElementById('overlay-pause-btn');
const overlayStopBtn = document.getElementById('overlay-stop-btn');
const overlayMinimizeBtn = document.getElementById('overlay-minimize-btn');

if (isMaximized) {
overlayControls.classList.add('visible');
overlayMinimizeBtn.disabled = false; // Always allow exit from maximized mode

if (isRecording) {
overlayPauseBtn.disabled = false;
overlayStopBtn.disabled = false;

// Update pause/resume text for overlay button
overlayPauseBtn.textContent = isPaused ? 'Resume' : 'Pause';
overlayPauseBtn.classList.toggle('btn-primary', isPaused);
overlayPauseBtn.classList.toggle('btn-warning', !isPaused);
} else {
// Maximize mode without recording
overlayPauseBtn.disabled = true;
overlayStopBtn.disabled = true;
overlayPauseBtn.textContent = 'Pause'; // Reset text
overlayPauseBtn.classList.remove('btn-primary');
overlayPauseBtn.classList.add('btn-warning');
}
} else {
overlayControls.classList.remove('visible');
// Ensure overlay buttons are disabled if overlay is not active
overlayPauseBtn.disabled = true;
overlayStopBtn.disabled = true;
overlayMinimizeBtn.disabled = true;
}
}


// --- Event Listeners ---
// document.getElementById('youtube-link').addEventListener('change', loadVideo); 
// Load video on input change/enter
document.getElementById('load-video-btn').addEventListener('click', loadVideo);

document.getElementById('start-video-btn').addEventListener('click', () => {
if (!currentVideoId) {
alert('Bitte laden Sie zuerst ein YouTube-Video.');
return;
}
if (!validateTimeInputs(player.getDuration())) {
return;
}
player.setPlaybackRate(parseFloat(document.getElementById('playback-speed').value));
player.seekTo(startTimeSeconds, true);
player.playVideo();
document.getElementById('download-link-container').style.display = 'none'; // Hide download link
});

document.getElementById('start-record-btn').addEventListener('click', () => {
// If not yet maximized, go maximized before recording
if (!isMaximized) {
toggleMaximizePlayer(true); // Force maximize
}
startRecording();
});
document.getElementById('pause-record-btn').addEventListener('click', pauseRecording);
document.getElementById('stop-record-btn').addEventListener('click', () => stopRecording(true));

// Listen for changes in playback speed
document.getElementById('playback-speed').addEventListener('change', (event) => {
if (player && player.getIframe()) { // Check if player is initialized
player.setPlaybackRate(parseFloat(event.target.value));
}
});

// Maximize button listeners
document.getElementById('toggle-maximize-btn').addEventListener('click', () => toggleMaximizePlayer());
document.getElementById('overlay-pause-btn').addEventListener('click', pauseRecording);
document.getElementById('overlay-stop-btn').addEventListener('click', () => stopRecording(true));
document.getElementById('overlay-minimize-btn').addEventListener('click', () => toggleMaximizePlayer(false)); // Explicitly minimize

// Listener for Escape key to exit maximized mode
document.addEventListener('keydown', (event) => {
if (event.key === 'Escape' && isMaximized && !isRecording) { // Only allow ESC to exit if not recording
toggleMaximizePlayer(false);
} else if (event.key === 'Escape' && isMaximized && isRecording) {
// Inform user that ESC is disabled during recording in maximized mode
console.log("Kann den vergrößerten Modus nicht mit ESC verlassen, während die Aufnahme läuft. Verwenden Sie den 'Exit'-Button oben.");
}
});

// Load YouTube Iframe API
const tag = document.createElement('script');
tag.src = "https://www.youtube.com/iframe_api";
const firstScriptTag = document.getElementsByTagName('script')[0];
firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
</script>
</body>
</html>