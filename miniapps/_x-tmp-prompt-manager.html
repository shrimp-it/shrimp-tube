<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Prompt Manager</title>
<style>
body {
font-family: Arial, sans-serif;
margin: 0;
padding: 0;
background-color: #2b2b2b;
color: #d4d4d4;
display: flex;
flex-direction: column;
min-height: 100vh;
}
#app-container {
flex-grow: 1;
padding: 15px;
max-width: 900px;
margin: 0 auto;
width: 100%;
display: flex;
flex-direction: column;
}
h2 {
color: #1d7efd;
margin-bottom: 20px;
text-align: center;
}
.controls {
margin-bottom: 15px;
display: flex;
gap: 10px;
flex-wrap: wrap; /* Allow controls to wrap on smaller screens */
}
.controls button {
padding: 8px 15px;
background-color: #007bff;
color: white;
border: none;
border-radius: 5px;
cursor: pointer;
transition: background-color 0.3s ease;
}
.controls button:hover {
background-color: #0056b3;
}
/* New style for the composition textarea within the manager */
#prompt-composition-textarea-in-manager {
width: calc(100% - 20px); /* Full width minus padding */
min-height: 120px; /* Default height */
height: auto;
resize: vertical; /* Allow vertical resizing by user */
padding: 10px;
margin: 0 auto 15px auto; /* Centered, spacing below */
border-radius: 8px;
border: 1px solid #555;
background-color: #3b4148; /* Darker background for composition */
color: #d4d4d4;
font-size: 1rem;
outline: none;
box-sizing: border-box; /* Include padding and border in width/height */
box-shadow: inset 0 0 5px rgba(0,0,0,0.3);
}
.table-container {
flex-grow: 1;
overflow-y: auto;
background-color: #333;
border-radius: 8px;
padding: 10px;
box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
margin-bottom: 15px;
}
table {
width: 100%;
border-collapse: collapse;
font-size: 0.9em;
}
th, td {
padding: 10px;
text-align: left;
border-bottom: 1px solid #444;
word-wrap: break-word; /* Ensure long text wraps */
}
th {
background-color: #444;
color: white;
position: sticky;
top: 0;
z-index: 1;
}
tr:hover {
background-color: #4a4a4a;
}
tr.selected {
background-color: #0056b3; /* Highlight color for selected rows */
}
/* Style for standard checkboxes */
td.standard-checkbox-cell input[type="checkbox"] {
pointer-events: none; /* Make checkbox non-interactive */
}
/* General input and select styles for potential future CRUD */
input[type="text"], textarea, select {
background-color: #444;
color: #d4d4d4;
border: 1px solid #555;
border-radius: 4px;
padding: 5px;
width: 100%;
box-sizing: border-box;
}
</style>
</head>
<body>
<div id="app-container">
<h2>Prompt Manager</h2>

<div class="controls">
<button id="import-csv-btn">CSV Import</button>
<button id="export-csv-btn">CSV Export</button>
<button id="add-row-btn">Neu</button>
<button id="edit-row-btn">Bearbeiten</button>
<button id="delete-row-btn">Löschen</button>
<button id="markdown-generator-btn">Markdown Generator</button>
</div>

<!-- NEW: Prompt composition textarea -->
<textarea id="prompt-composition-textarea-in-manager" placeholder="Stelle deinen KI-Prompt hier zusammen..."></textarea>

<div class="table-container">
<table id="prompt-table">
<thead>
<tr>
<th>Auswahl</th>
<th>Standard</th>
<th>Prompt Name</th>
<th>Prompt Gruppe</th>
<th>Kurzbeschreibung</th>
</tr>
</thead>
<tbody>
<!-- Prompt-Daten werden hier dynamisch eingefügt -->
</tbody>
</table>
</div>

<div class="footer-controls">
<button id="done-btn">Fertig</button>
</div>
</div>

<script>
document.addEventListener('DOMContentLoaded', () => {
const PROMPT_CSV_URL = './prompt-presets.csv';
const promptTableBody = document.querySelector('#prompt-table tbody');
const promptCompositionTextarea = document.getElementById('prompt-composition-textarea-in-manager');

// --- Utility Functions ---

function correctUmlauts(text) {
if (typeof text !== 'string') return text;
return text
.replace(/�/g, 'ä')
.replace(/�/g, 'ö')
.replace(/�/g, 'ü')
.replace(/�/g, 'Ä')
.replace(/�/g, 'Ö')
.replace(/�/g, 'Ü')
.replace(/�/g, 'ß');
}

function parseCSVData(csvText) {
const lines = csvText.trim().split('\n');
if (lines.length === 0) return [];

// Correct umlauts in header line before splitting
const headersRaw = correctUmlauts(lines[0]).split(';');
const headersCleaned = headersRaw.map(h => h.trim());

let delimiter = ';';
let parsedRows = [];

// Helper to parse a single line with a given delimiter
const parseLine = (line, del) => {
const values = line.split(del);
return headersCleaned.reduce((obj, header, index) => {
obj[header] = correctUmlauts(values[index] || '').trim();
return obj;
}, {});
};

// Attempt with semicolon first
parsedRows = lines.slice(1).map(line => parseLine(line, ';'));

// Heuristic check: if the first data row (after headers) has fewer columns than expected,
// or if it has only one column but contains a comma, assume semicolon failed.
const firstDataRowValues = lines[1] ? lines[1].split(';') : [];
const expectedMinColumns = headersCleaned.length;

if (firstDataRowValues.length < expectedMinColumns || (firstDataRowValues.length === 1 && lines[1].includes(','))) {
delimiter = ',';
parsedRows = lines.slice(1).map(line => parseLine(line, ','));
console.warn('CSV parsing: Semicolon failed or insufficient columns, retrying with comma delimiter.');
} else {
console.log('CSV parsing: Successfully parsed with semicolon delimiter.');
}

return parsedRows.filter(row => Object.values(row).some(value => value !== ''));
}

function renderTable(data) {
promptTableBody.innerHTML = '';
data.forEach(row => {
const tr = document.createElement('tr');
tr.dataset.promid = row['PromID'];
tr.dataset.textBlock = row['Befehl-Text-Block']; // Store full text block

const selectTd = document.createElement('td');
const selectCheckbox = document.createElement('input');
selectCheckbox.type = 'checkbox';
selectCheckbox.classList.add('prompt-select-checkbox');
selectTd.appendChild(selectCheckbox);
tr.appendChild(selectTd);

const standardTd = document.createElement('td');
standardTd.classList.add('standard-checkbox-cell');
const standardCheckbox = document.createElement('input');
standardCheckbox.type = 'checkbox';
standardCheckbox.checked = row['standard'] === 'true';
standardTd.appendChild(standardCheckbox);
tr.appendChild(standardTd);

const nameTd = document.createElement('td');
nameTd.textContent = row['Prompt-Befehl-Name'];
tr.appendChild(nameTd);

const groupTd = document.createElement('td');
groupTd.textContent = row['Prompt-Gruppe'];
tr.appendChild(groupTd);

const descTd = document.createElement('td');
descTd.textContent = row['Kurzbeschreibung'];
tr.appendChild(descTd);

promptTableBody.appendChild(tr);
});
}

async function loadAndParseCSV() {
try {
const response = await fetch(PROMPT_CSV_URL);
if (!response.ok) {
throw new Error(`HTTP error! status: ${response.status}`);
}
const csvText = await response.text();
const parsedData = parseCSVData(csvText);
renderTable(parsedData);
console.log('CSV data loaded and rendered.');
} catch (error) {
console.error('Error loading or parsing CSV:', error);
promptTableBody.innerHTML = `<tr><td colspan="5">Fehler beim Laden der Prompts: ${error.message}</td></tr>`;
}
}

// --- Event Listeners ---

promptTableBody.addEventListener('change', (event) => {
if (event.target.classList.contains('prompt-select-checkbox')) {
const row = event.target.closest('tr');
if (event.target.checked) {
row.classList.add('selected');
console.log('Selected prompt:', row.dataset.promid);
// Task 3.2 will handle text area update here
} else {
row.classList.remove('selected');
console.log('Deselected prompt:', row.dataset.promid);
// Task 3.2 will handle text area update here
}
}
});

document.getElementById('markdown-generator-btn').addEventListener('click', () => {
window.open('../markdown-aus-files-generator.html', '_blank');
});

document.getElementById('done-btn').addEventListener('click', () => {
// Get the final prompt text from the local composition textarea
const finalPromptText = promptCompositionTextarea.value;

if (window.parent) {
// Send the final prompt text back to the parent frame (shrimp-editor-ai-frame.html)
window.parent.postMessage({
type: 'set-final-prompt-input',
finalPromptText: finalPromptText,
source: 'user-prompt-manager.html',
submitOnDone: true // Indicates that the prompt should be submitted after setting
}, '*');

// Close the modal itself (assuming it's in an iframe within myboModal3)
const myboModal3 = window.parent.document.getElementById("myboModal3");
if (myboModal3) {
myboModal3.style.display = "none";
}
}
});

// Initial load of data
loadAndParseCSV();
});
</script>
</body>
</html>